// Created with IntelliJ IDEA.
// User: Nathanael
// Date: 10/2/12
// Time: 9:57 PM
// this is a test
public class Assembler {
    private Set<String> preLoadedOpcodes = new HashSet<String>();
    public int INT = 4;
    public int INSTRUCTION = 12;
    public int BYT = 1;
    public HashMap<String, String> reg = new HashMap<String, String>();
    public List<Memory> mem = new ArrayList<Memory>();
    HashMap<String, Integer> symbolTable = new HashMap<String, Integer>();

    private final int ADD=20;
    private final int SUB = 21;
    private final int MUL = 22;
    private final int DIV = 23;
    private final int LDR = 24;
    private final int TRP = 25;
    private final int LDA = 26;
    private final int JMP = 27;
    private final int CMP = 28;
    private final int BNZ = 29;
    private final int ADDI = 30;
    private final int MOV = 31;
    private final int ADI = 32;
    private final int JMR = 33;
    private final int STR = 34;
    private final int STRI = 35;
    private final int BLT = 36;
    private final int BRZ = 37;

    private void preloadReg() {
        reg.put("0","0");
        reg.put("1", "0");
        reg.put("2", "0");
        reg.put("3", "0");
        reg.put("4", "0");
        reg.put("5", "0");
        reg.put("6", "0");
        reg.put("7", "0");
        reg.put("8", "0");
        reg.put("9", "0");
        reg.put("10", "0");
    }

    private void loadOpcodes() {
        preLoadedOpcodes.add("TRP");
        preLoadedOpcodes.add("ADD");
        preLoadedOpcodes.add("SUB");
        preLoadedOpcodes.add("DIV");
        preLoadedOpcodes.add("MUL");
        preLoadedOpcodes.add("LDR");
        preLoadedOpcodes.add("LDA");
        preLoadedOpcodes.add("JMP");
        preLoadedOpcodes.add("CMP");
        preLoadedOpcodes.add("BNZ");
        preLoadedOpcodes.add("ADDI");
        preLoadedOpcodes.add("MOV");
        preLoadedOpcodes.add("ADI");
        preLoadedOpcodes.add("JMR");
        preLoadedOpcodes.add("STR");
        preLoadedOpcodes.add("STRI");
        preLoadedOpcodes.add("BLT");
        preLoadedOpcodes.add("BRZ");
    }

    public void action() {
        loadOpcodes();

        try {
            String file;
            BufferedReader readInput = new BufferedReader(new InputStreamReader(System.in));
            file = readInput.readLine();
            BufferedReader reader = new BufferedReader(new FileReader(file));
            String lastLabelLoaded = null;
            String lastDirectiveLoaded = null;

            //  get line count for the read in file
            int count = 0;
            while (reader.readLine() != null) {
                count++;
            }

            // pass one; build symbol table
            symbolTable.put("INPT", INT);
            symbolTable.put("INCT", INT);
            mem.add(new Memory("INPT", ""));
            mem.add(new Memory("", ""));
            mem.add(new Memory("", ""));
            mem.add(new Memory("", ""));
            mem.add(new Memory("", ""));
            mem.add(new Memory("", ""));
            mem.add(new Memory("", ""));
            mem.add(new Memory("INCT", "0"));
            BufferedReader reader2 = new BufferedReader(new FileReader(file));
            String line = null;
            String[] lineInfo;
            int byteCount = 0;

            while ((line = reader2.readLine()) != null) {
                if (line.trim().length() == 0) {
                    continue;
                }

                lineInfo = line.trim().split("[\t ]+");


                if (!preLoadedOpcodes.contains(lineInfo[0])) {

                    if (symbolTable.containsKey(lineInfo[0].trim())) {
                        System.out.println("Assembly file cannot have duplicate Label names");
                        return;
                    }

                    // handle int arrays
                    if (lastLabelLoaded != null) {
                        if (isDirective(lineInfo[0].trim())) {
                            if (!lastDirectiveLoaded.equals(lineInfo[0].trim())) {
                                System.out.println("Array elements must be of the same type");
                                return;
                            }
                            mem.add(new Memory("", lineInfo[1]));
                            if (lineInfo[0].equals(".INT")) {
                                byteCount += INT;
                            } else {
                                byteCount += BYT;
                            }
                            continue;
                        }
                    }

                    symbolTable.put(lineInfo[0].trim(), byteCount);

                    if (lineInfo[1].equals(".INT")) {
                        byteCount += INT;
                        mem.add(new Memory(lineInfo[0].trim(), lineInfo[2]));

                        lastDirectiveLoaded = lineInfo[1].trim();
                        lastLabelLoaded = lineInfo[0].trim();
                    } else if (lineInfo[1].equals(".BYT")) {
                        byteCount += BYT;
                        int asciiTest = 0;

                        if (lineInfo[2].substring(1, lineInfo[2].length() - 1).matches("^[0-9]+$")) {
                            asciiTest = Integer.parseInt(lineInfo[2].substring(1, lineInfo[2].length() - 1));
                            if (asciiTest == 32) {
                                mem.add(new Memory(lineInfo[0].trim(), " "));
                            } else if (asciiTest == 13) {
                                mem.add(new Memory(lineInfo[0].trim(), "\r\n"));
                            } else {
                                mem.add(new Memory(lineInfo[0].trim(), lineInfo[2].substring(1, lineInfo[2].length() - 1)));
                            }
                        } else {
                            mem.add(new Memory(lineInfo[0].trim(), lineInfo[2].substring(1, lineInfo[2].length() - 1)));
                        }

                        lastDirectiveLoaded = lineInfo[1].trim();
                        lastLabelLoaded = lineInfo[0].trim();
                    } else if (lineInfo[0].trim().length() > 4) {
                        if (lineInfo[1].equals("TRP") || lineInfo[1].equals("JMP") || lineInfo[1].equals("JMR")) {
                            mem.add(new Memory(lineInfo[0].trim(), lineInfo[1] + "\t" + lineInfo[2]));
                        } else {
                            mem.add(new Memory(lineInfo[0].trim(), lineInfo[1] + "\t" + lineInfo[2] + "\t" + lineInfo[3]));
                        }
                        byteCount += INSTRUCTION;
                    }
                }
            }


            // pass two; check syntax, references
            BufferedReader reader3 = new BufferedReader(new FileReader(file));
            List<Instruction> instructionList = new ArrayList<Instruction>();

            int counter = 1;
            while ((line = reader3.readLine()) != null) {
                if (line.trim().length() == 0) {
                    counter++;
                    continue;
                }

                lineInfo = line.trim().split("[\t ]+");

                // check TRP for correct layout
                if (checkForTRPLayout(lineInfo, counter, instructionList)) return;

                if (checkForRegImmLabels(lineInfo, counter, instructionList)) return;

                // check for operator Labels
                if (checkForRegRegLabels(lineInfo, counter, instructionList)) return;

                // check for LDR labels
                if (checkForRegMemLabels(symbolTable, lineInfo, counter, instructionList)) return;

                // check for valid jmp
                if (checkForJMPLayout(symbolTable, lineInfo, counter, instructionList)) return;

                // check for valid jmr
                if (checkForJMRLayout(lineInfo, counter, instructionList)) return;

                return reg.put(instr.getOpd1(), instr.getOpd2());
            case ADD:
                instr = new Instruction(switcher, instructions[1].substring(1, instructions[1].length()), instructions[2].substring(1, instructions[2].length()));
                if (!validOpd(instr)) {
                    System.out.println("Error on instruction: " + instr.getOpCode() + " " + instr.getOpd1() + " " + instr.getOpd2() + " the ADD instruction requires integer values in the registers being added");
                    return null;
                }

                retValue = Integer.parseInt(reg.get(instr.getOpd1())) + Integer.parseInt(reg.get(instr.getOpd2()));
                return retValue.toString();
            case ADDI:
                if (!reg.get(instr.getOpd1()).matches("^(-|\\+)?[0-9]+$")) {
                    System.out.println("Error on instruction: " + instr.getOpCode() + " " + instr.getOpd1() + " " + instr.getOpd2() + " the ADDI instruction requires integer values in the registers being added");
                    break;
                }
                if (!mem.get(Integer.parseInt(reg.get(instr.getOpd2()))).getData().matches("^(-|\\+)?[0-9]+$")) {
                    System.out.println("Error on instruction: " + instr.getOpCode() + " " + instr.getOpd1() + " " + instr.getOpd2() + " the ADDI instruction requires integer values in the registers being added");
                    break;
                }

                Integer newValue = Integer.parseInt(reg.get(instr.getOpd1())) + Integer.parseInt(mem.get(Integer.parseInt(reg.get(instr.getOpd2()))).getData());
                return newValue.toString();
            case SUB:
                instr = new Instruction(switcher, instructions[1].substring(1, instructions[1].length()), instructions[2].substring(1, instructions[2].length()));
                if (!validOpd(instr)) {
                    System.out.println("Error on instruction: " + instr.getOpCode() + " " + instr.getOpd1() + " " + instr.getOpd2() + " the SUB instruction requires integer values in the registers being subtracted");
                    return null;
                }

                retValue = Integer.parseInt(reg.get(instr.getOpd1())) - Integer.parseInt(reg.get(instr.getOpd2()));
                return retValue.toString();
            case MUL:
                instr = new Instruction(switcher, instructions[1].substring(1, instructions[1].length()), instructions[2].substring(1, instructions[2].length()));
                if (!validOpd(instr)) {
                    System.out.println("Error on instruction: " + instr.getOpCode() + " " + instr.getOpd1() + " " + instr.getOpd2() + " the MUL instruction requires integer values in the registers being multiplied");
                    return null;
                }

                retValue = Integer.parseInt(reg.get(instr.getOpd1())) * Integer.parseInt(reg.get(instr.getOpd2()));
                return retValue.toString();
            case DIV:
                instr = new Instruction(switcher, instructions[1].substring(1, instructions[1].length()), instructions[2].substring(1, instructions[2].length()));
                if (!validOpd(instr)) {
                    System.out.println("Error on instruction: " + instr.getOpCode() + " " + instr.getOpd1() + " " + instr.getOpd2() + " the DIV instruction requires integer values in the registers being divided");
                    return null;
                }

                if (Integer.parseInt(reg.get(instr.getOpd2())) == 0) {
                    System.out.println("Error on instruction: " + instr.getOpCode() + " " + instr.getOpd1() + " " + instr.getOpd2() + " -> Can not divide by zero");
                    return null;
                }

                retValue = Integer.parseInt(reg.get(instr.getOpd1())) / Integer.parseInt(reg.get(instr.getOpd2()));
                return retValue.toString();
            case LDR:
                instr = new Instruction(switcher, instructions[1].substring(1, instructions[1].length()), instructions[2]);
                String opdTwo = "";

                if (instr.getOpd2().length() > 4) {
                    opdTwo = handleInstruction(instr.getOpd2());
                } else {
                    for (Memory m : mem) {
                        if (m.getLabel().equals(instr.getOpd2())) {
                            return m.getData();
                        }
                    }
                }

                break;
            case LDA:
                newValue = -1;
                for (Memory m : mem) {
                    if (m.getLabel().equals(instr.getOpd2())) {
                        newValue = mem.indexOf(m);
                        return newValue.toString();
                    }
                }

                if (newValue < 0) {
                    System.out.println("Error on instruction: " + instr.getOpCode() + " " + instr.getOpd1() + " " + instr.getOpd2() + " the LDA instruction requires a valid label.");
                    return null;
                }

                break;
            case MOV:
                return reg.get(instr.getOpd2());
            default:
                // do nothing
                break;
        }
        return null;
    }

    private boolean validOpd(Instruction instr) {
        if (!reg.get(instr.getOpd1()).matches("^(-|\\+)?[0-9]+$")) {
            System.out.println("Error on instruction: " + instr.getOpCode() + " " + instr.getOpd1() + " " + instr.getOpd2() + " the ADD instruction requires integer values in the registers being added");
            return false;
        }
        if (!reg.get(instr.getOpd2()).matches("^(-|\\+)?[0-9]+$")) {
            System.out.println("Error on instruction: " + instr.getOpCode() + " " + instr.getOpd1() + " " + instr.getOpd2() + " the ADD instruction requires integer values in the registers being added");
            return false;
        }
        return true;
    }

    private boolean validADIOpd(Instruction instr) {
        if (!reg.get(instr.getOpd1()).matches("^(-|\\+)?[0-9]+$")) {
            System.out.println("Error on instruction: " + instr.getOpCode() + " " + instr.getOpd1() + " " + instr.getOpd2() + " the ADI instruction requires integer values in the registers being added");
            return false;
        }
        return true;
    }

    private boolean checkForTRPLayout(String[] lineInfo, int counter, List<Instruction> instructions) {
        if (lineInfo[0].equals("TRP")) {
            if (!lineInfo[1].matches("^(\\d|4)$")) {
                System.out.println("invalid trap type on line: " + counter + ".  Must choose from 0 - 4");
                return true;
            }
            instructions.add(new Instruction(TRP, lineInfo[1]));
        } else if (lineInfo[1].equals("TRP")) {
            if (!lineInfo[2].matches("^(\\d|4)$")) {
                System.out.println("invalid trap type on line: " + counter + ".  Must choose from 0 - 4");
                return true;
            }
            instructions.add(new Instruction(TRP, lineInfo[2], "", lineInfo[0].trim()));
        }
        return false;
    }

    private boolean checkForRegImmLabels(String[] lineInfo, int counter, List<Instruction> instructions) {
        if (lineInfo[0].equals("ADI")) {
            if (!lineInfo[1].matches("^R(\\d|10)$")) {
                System.out.println("Line " + counter + ": operand 1 must be a valid register");
                return true;
            }
            if (!lineInfo[2].matches("^(-|\\+)?[0-9]+$")) {
                System.out.println("Line " + counter + ": operand 2 must be a valid integer");
                return true;
            }
            instructions.add(new Instruction(ADI, lineInfo[1].substring(1, lineInfo[1].length()), lineInfo[2]));
        } else if (lineInfo[1].equals("ADI")) {
            if (!lineInfo[2].matches("^R(\\d|10)$")) {
                System.out.println("Line " + counter + ": operand 1 must be a valid register");
                return true;
            }
            if (!lineInfo[3].matches("^(-|\\+)?[0-9]+$")) {
                System.out.println("Line " + counter + ": operand 2 must be a valid integer");
                return true;
            }
            instructions.add(new Instruction(ADI, lineInfo[2].substring(1, lineInfo[2].length()), lineInfo[3].trim(), lineInfo[0].trim()));
        }
        return false;
    }

    private boolean checkForRegRegLabels(String[] lineInfo, int counter, List<Instruction> instructions) {
        if (lineInfo[0].equals("ADD") || lineInfo[0].equals("SUB") || lineInfo[0].equals("MUL") || lineInfo[0].equals("DIV") || lineInfo[0].equals("CMP") || lineInfo[0].equals("ADDI") || lineInfo[0].equals("MOV") || lineInfo[0].equals("STRI")) {
            if (!lineInfo[1].matches("^R(\\d|10)$")) {
                System.out.println("Line " + counter + ": operand 1 must be a valid register");
                return true;
            }
            if (!lineInfo[2].matches("^R(\\d|10)$")) {
                System.out.println("Line " + counter + ": operand 2 must be a valid register");
                return true;
            }

            if (lineInfo[0].equals("ADD")) {
                instructions.add(new Instruction(ADD, lineInfo[1].substring(1, lineInfo[1].length()), lineInfo[2].substring(1, lineInfo[2].length())));
            } else if (lineInfo[0].equals("SUB")) {
                instructions.add(new Instruction(SUB, lineInfo[1].substring(1, lineInfo[1].length()), lineInfo[2].substring(1, lineInfo[2].length())));
            } else if (lineInfo[0].equals("MUL")) {
                instructions.add(new Instruction(MUL, lineInfo[1].substring(1, lineInfo[1].length()), lineInfo[2].substring(1, lineInfo[2].length())));
            } else if (lineInfo[0].equals("DIV")) {
                instructions.add(new Instruction(DIV, lineInfo[1].substring(1, lineInfo[1].length()), lineInfo[2].substring(1, lineInfo[2].length())));
            } else if (lineInfo[0].equals("ADDI")) {
                instructions.add(new Instruction(ADDI, lineInfo[1].substring(1, lineInfo[1].length()), lineInfo[2].substring(1, lineInfo[2].length())));
            } else if (lineInfo[0].equals("MOV")) {
                instructions.add(new Instruction(MOV, lineInfo[1].substring(1, lineInfo[1].length()), lineInfo[2].substring(1, lineInfo[2].length())));
            } else if (lineInfo[0].equals("STRI")) {
                instructions.add(new Instruction(STRI, lineInfo[1].substring(1, lineInfo[1].length()), lineInfo[2].substring(1, lineInfo[2].length())));
            } else {
                instructions.add(new Instruction(CMP, lineInfo[1].substring(1, lineInfo[1].length()), lineInfo[2].substring(1, lineInfo[2].length())));
            }

        } else if (lineInfo[1].equals("ADD") || lineInfo[1].equals("SUB") || lineInfo[1].equals("MUL") || lineInfo[1].equals("DIV") || lineInfo[1].equals("CMP") || lineInfo[1].equals("ADDI") || lineInfo[1].equals("MOV") || lineInfo[1].equals("STRI")) {
            if (!lineInfo[2].matches("^R(\\d|10)$")) {
                System.out.println("Line " + counter + ": operand 1 must be a valid register");
                return true;
            }
            if (!lineInfo[3].matches("^R(\\d|10)$")) {
                System.out.println("Line " + counter + ": operand 2 must be a valid register");
                return true;
            }

            if (lineInfo[1].equals("ADD")) {
                instructions.add(new Instruction(ADD, lineInfo[2].substring(1, lineInfo[2].length()), lineInfo[3].substring(1, lineInfo[3].length()), lineInfo[0].trim()));
            } else if (lineInfo[1].equals("SUB")) {
                instructions.add(new Instruction(SUB, lineInfo[2].substring(1, lineInfo[2].length()), lineInfo[3].substring(1, lineInfo[3].length()), lineInfo[0].trim()));
            } else if (lineInfo[1].equals("MUL")) {
                instructions.add(new Instruction(MUL, lineInfo[2].substring(1, lineInfo[2].length()), lineInfo[3].substring(1, lineInfo[3].length()), lineInfo[0].trim()));
            } else if (lineInfo[1].equals("DIV")) {
                instructions.add(new Instruction(DIV, lineInfo[2].substring(1, lineInfo[2].length()), lineInfo[3].substring(1, lineInfo[3].length()), lineInfo[0].trim()));
            } else if (lineInfo[1].equals("ADDI")) {
                instructions.add(new Instruction(ADDI, lineInfo[2].substring(1, lineInfo[2].length()), lineInfo[3].substring(1, lineInfo[3].length()), lineInfo[0].trim()));
            } else if (lineInfo[1].equals("MOV")) {
                instructions.add(new Instruction(MOV, lineInfo[2].substring(1, lineInfo[2].length()), lineInfo[3].substring(1, lineInfo[3].length()), lineInfo[0].trim()));
            } else if (lineInfo[1].equals("STRI")) {
                instructions.add(new Instruction(STRI, lineInfo[2].substring(1, lineInfo[2].length()), lineInfo[3].substring(1, lineInfo[3].length()), lineInfo[0].trim()));
            } else {
                instructions.add(new Instruction(CMP, lineInfo[2].substring(1, lineInfo[2].length()), lineInfo[3].substring(1, lineInfo[3].length()), lineInfo[0].trim()));
            }
        }
        return false;
    }

    private boolean checkForRegMemLabels(HashMap<String, Integer> symbolTable, String[] lineInfo, int counter, List<Instruction> instructions) {
        if (lineInfo[0].equals("LDR") || lineInfo[0].equals("LDA") || lineInfo[0].equals("BNZ") || lineInfo[0].equals("STR") || lineInfo[0].equals("BLT") || lineInfo[0].equals("BRZ")) {

            if (!lineInfo[1].matches("^R(\\d|10)$")) {
                System.out.println("Line " + counter + ": operand 1 must be a valid register");
                return true;
            }
            if (!symbolTable.containsKey(lineInfo[2])) {
                System.out.println("Label at line: " + counter + " operand 2 does not exist");
                return true;
            }

            if (lineInfo[0].equals("LDR")) {
                instructions.add(new Instruction(LDR, lineInfo[1].substring(1, lineInfo[1].length()), lineInfo[2]));
            } else if (lineInfo[0].equals("LDA")) {
                instructions.add(new Instruction(LDA, lineInfo[1].substring(1, lineInfo[1].length()), lineInfo[2]));
            } else if (lineInfo[0].equals("BNZ")) {
                if (lineInfo[2].length() <= 4) {
                    System.out.println("Label at line: " + counter + " must be associated with an instruction not a directive.");
                    return true;
                }

                instructions.add(new Instruction(BNZ, lineInfo[1].substring(1, lineInfo[1].length()), lineInfo[2]));
            } else if (lineInfo[0].equals("BLT")) {
                if (lineInfo[2].length() <= 4) {
                    System.out.println("Label at line: " + counter + " must be associated with an instruction not a directive.");
                    return true;
                }

                instructions.add(new Instruction(BLT, lineInfo[1].substring(1, lineInfo[1].length()), lineInfo[2]));
            } else if (lineInfo[0].equals("BRZ")) {
                if (lineInfo[2].length() <= 4) {
                    System.out.println("Label at line: " + counter + " must be associated with an instruction not a directive.");
                    return true;
                }

                instructions.add(new Instruction(BRZ, lineInfo[1].substring(1, lineInfo[1].length()), lineInfo[2]));
            } else if (lineInfo[0].equals("STR")) {
                instructions.add(new Instruction(STR, lineInfo[1].substring(1, lineInfo[1].length()), lineInfo[2]));
            }

        } else if (lineInfo[1].equals("LDR") || lineInfo[1].equals("LDA") || lineInfo[1].equals("BNZ") || lineInfo[1].equals("STR") || lineInfo[1].equals("BLT") || lineInfo[1].equals("BRZ")) {

            if (!lineInfo[2].matches("^R(\\d|10)$")) {
                System.out.println("Line " + counter + ": operand 1 must be a valid register");
                return true;
            }
            if (!symbolTable.containsKey(lineInfo[3])) {
                System.out.println("Label at line: " + counter + " operand 2 does not exist");
                return true;
            }

            if (lineInfo[1].equals("LDR")) {
                instructions.add(new Instruction(LDR, lineInfo[2].substring(1, lineInfo[2].length()), lineInfo[3], lineInfo[0].trim()));
            } else if (lineInfo[1].equals("LDA")) {
                instructions.add(new Instruction(LDA, lineInfo[2].substring(1, lineInfo[2].length()), lineInfo[3], lineInfo[0].trim()));
            } else if (lineInfo[1].equals("BNZ")) {
                if (lineInfo[3].length() <= 4) {
                    System.out.println("Label at line: " + counter + " must be associated with an instruction not a directive.");
                    return true;
                }

                instructions.add(new Instruction(BNZ, lineInfo[2].substring(1, lineInfo[2].length()), lineInfo[3], lineInfo[0].trim()));
            } else if (lineInfo[1].equals("BLT")) {
                if (lineInfo[3].length() <= 4) {
                    System.out.println("Label at line: " + counter + " must be associated with an instruction not a directive.");
                    return true;
                }

                instructions.add(new Instruction(BLT, lineInfo[2].substring(1, lineInfo[2].length()), lineInfo[3], lineInfo[0].trim()));
            } else if (lineInfo[1].equals("BRZ")) {
                if (lineInfo[3].length() <= 4) {
                    System.out.println("Label at line: " + counter + " must be associated with an instruction not a directive.");
                    return true;
                }

                instructions.add(new Instruction(BRZ, lineInfo[2].substring(1, lineInfo[2].length()), lineInfo[3], lineInfo[0].trim()));
            } else if (lineInfo[1].equals("STR")) {
                instructions.add(new Instruction(STR, lineInfo[2].substring(1, lineInfo[2].length()), lineInfo[3]));
            }
        }
        return false;
    }
}
